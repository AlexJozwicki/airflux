{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 7d84883832a67f444bdd","webpack:///./src/Publisher.js","webpack:///external \"invariant\"","webpack:///./src/utils.js","webpack:///./src/Listener.js","webpack:///./src/Action.js","webpack:///./src/AsyncResultAction.js","webpack:///./src/Store.js","webpack:///./src/Environment.js","webpack:///external \"react\"","webpack:///./src/index.js","webpack:///external \"eventemitter3\"","webpack:///./src/PromiseAction.js","webpack:///./src/Join.js","webpack:///./src/QueryRenderer.jsx","webpack:///./src/AirfluxApp.js","webpack:///./src/JoinStores.js"],"names":["_","Publisher","_emitter","EventEmitter","result","callback","eventHandler","aborted","unsubscribe","args","setTimeout","isObject","type","isFunction","isArguments","value","Listener","_subscriptions","listenable","pubs","r","sub","pub","desub","subscriptionObj","unsubscriber","index","subs","i","stop","subscription","remaining","defaultState","defaultCallback","listenables","strategy","Join","subobj","Action","sync","children","action","Object","Array","child","name","triggerFn","functor","AsyncResultAction","promise","removeSuccess","removeFailed","resolve","reject","Store","store","initialState","partialState","Environment","stores","default","Joins","Core","PromiseAction","slice","_args","_listenablesEmitted","cancels","callargs","React","QueryRenderer","_listener","publishers","console","Component","contextTypes","airflux","PropTypes","AirfluxApp","environment","childContextTypes","joinStrict","joinClassFactory","joinLeading","all","joinTrailing","joinConcat"],"mappings":"AAAA,eACA,iDADA,CAEA,kBAFA,CAGA,qCAHA,CAIA,sBAJA,CAKA,wBALA,CAMA,mBANA,CAQA,aACC,CATD,EASC,kCATD,CASC,WACD,M,aCNA,cAGA,QACA,oBAGA,YACA,GADA,CAEA,IAFA,CAGA,UAHA,EAaA,MANA,mCAMA,CAHA,MAGA,UACA,CAxBA,SA4DA,MAhCA,MAgCA,CA7BA,KA6BA,CA1BA,oBACA,QADA,EAEA,2BACA,eADA,CAEA,aAFA,CAGA,KAHA,EAMA,CAkBA,CAfA,gBACA,sBACA,WAA2B,mBAA4B,CADvD,CAEA,WAAiC,QAAe,CAFhD,CAIA,MADA,aACA,EACA,CASA,CANA,kBAAsD,gDAA+D,CAMrH,CAHA,MAGA,U,+kBC5DA,M,CAAYA,E,2JACZ,M,QACA,O,QAWqBC,E,WAMjB,YAAc,gBALdC,QAKc,CALW,GAAIC,GAAJ,OAMxB,C,uCAQcC,UAAwB,CAAE,C,sBAQjCC,WAAqD,YACzD,wBAAW,UAAX,oDADyD,IAGzD,KAHyD,CAKrDC,aAA2B,IAE3B,gBAAoBD,EAApB,KAAoBA,KAApB,CAFJ,CALyD,CAYzD,MAFA,2BAA2B,KAA3B,aAEA,CAAO,UAAM,CACTE,IADS,CAET,0BAA8B,EAA9B,aAFJ,CAIH,C,0BAGWF,WAAqD,YAC7D,wBAAW,UAAX,wDAD6D,CAG7D,GAAIG,GAAc,YAAa,UAAsB,4BAAjBC,EAAiB,qBAAjBA,KAAiB,YAAjBA,CAEhC,MADAD,IACA,CAAOH,EAAP,KAAOA,KAFX,CAAkB,CAAlB,CAIA,QACH,C,qCAK2B,4BAAZI,EAAY,qBAAZA,KAAY,YAAZA,CACZ,mBAAoB,KAApB,aACH,C,iCAKuB,mCAAZA,EAAY,qBAAZA,KAAY,YAAZA,CACRC,WAAY,iBAAM,uBAAN,IAAM,CAAlBA,IACH,C,kCAvDyB,CAAE,aAAiB,C,WAT5BT,O,gBCdrB,8B,gSCMgBU,Q,CAAT,WAAgD,CACnD,GAAIC,qCAAJ,KACA,MAAOA,gBAAuBA,cAAqB,CAAnD,EACH,C,GAEeC,U,CAAT,WAA6C,CAChD,gBAAO,UACV,C,GAEeC,W,CAAT,WAAqD,CACxD,MAAO,mEAAP,QAA2D,QAAOC,GAAP,MAC9D,C,w7BChBD,M,CAAYf,E,2JACZ,M,QAEA,M,QACA,O,QAqBqBgB,E,wNACjBC,c,0DASaC,WAAkC,CAE3C,GAAMC,GAAmD,2BAC5C,oBAAcC,UAAUC,EAAxB,UAAcD,CAD3B,CAAyD,IAAzD,CAGA,MAAO,QAAW,kBAASE,QAAwBA,gBAA2BA,EAA5D,WAA4DA,GAA9E,CAAO,CACV,C,iCASkBJ,WAA+C,CAC9D,cAAWA,IAAX,gDAD8D,CAE9D,wBAAW,QAAOA,GAAP,MAAX,oCAF8D,CAG9D,cAAW,EAAGA,gBAAkCA,cAAhD,IAAgDA,CAArC,CAAX,sEACH,C,wBAWSA,aAAsH,YAC5H,yBAD4H,CAE5H,kBAAWb,GAAX,mDAF4H,IAOxHkB,GAAQL,SAAmBb,OAA/B,IAA+BA,CAAnBa,CAPgH,CAetHM,EAAkB,KAAxB,eAAwB,CAPpBC,UAAqB,CACrB,GAAIC,GAAQ,iBAAZ,OAAY,GAAZ,CACA,eAAWA,GAAX,gEAFqB,CAGrB,4BAHqB,CAIrBH,GAJJ,CAOwB,GAfoG,CAgB5H,QACH,C,+BAQgBL,WAAkC,CAG/C,UAFIS,EAAO,KAAX,cAAW,IAEX,CAASC,EAAT,EAAgBA,EAAID,EAApB,WAEI,KADA,IACA,CAAIN,EAAJ,UAAIA,IAAJ,CAGI,MAFAA,SAEA,CADA,cAAmC,CAAnC,CAAWM,eAAX,oDACA,IAGR,QACH,C,+BAKgBE,aAAoF,CACjG,GAAML,GAAoC,QAA1C,YAA0C,CAA1C,CAEA,MADA,4BACA,EACH,C,kCAKmBM,WAAgC,CAChD,GAAMJ,GAAQ,oBAAd,OAAc,GAAd,CACA,CAAIA,EAF4C,EAIhD,+BACH,C,4CAMoB,QACXC,GAAO,KAAb,cAAa,IADI,CAEbI,EAAJ,CAFiB,CAIVA,EAAYJ,EAAnB,MAJiB,EAKbA,WALa,CAMb,cAAWA,WAAgBI,EAA3B,qDAEP,C,iCAOkBb,aAAsD,CACrE,GAAIlB,iBAAmC,CAAC,CAACkB,EAAzC,MAA4D,CACxD,GAAIc,GAAiBd,YAAsBjB,GAAtBiB,QAAkCA,EAAlCA,MAArB,KACAe,cACH,CACJ,C,4BAQa5B,WAA2E,4BAApD6B,EAAoD,6BAApDA,EAAoD,GAApDA,EAAoD,YAApDA,CACjC,MAAO,kBAAP,MAAO,KACV,C,2BAUY7B,WAA2E,4BAApD6B,EAAoD,6BAApDA,EAAoD,GAApDA,EAAoD,YAApDA,CAChC,MAAO,kBAAP,OAAO,KACV,C,0BASW7B,WAA2E,4BAApD6B,EAAoD,6BAApDA,EAAoD,GAApDA,EAAoD,YAApDA,CAC/B,MAAO,kBAAP,KAAO,KACV,C,0BAUW7B,WAA2E,4BAApD6B,EAAoD,6BAApDA,EAAoD,GAApDA,EAAoD,YAApDA,CAC/B,MAAO,kBAAP,QAAO,KACV,C,2BAGYC,eAAkG,YAC3G,eAAWD,UAAX,sDAD2G,CAI3GA,UAAqB,kBAAc,GAAd,iBAAc,GAAnCA,EAJ2G,IAMrGL,GAA4B,GAAIO,GAAJ,aAAlC,MAAkC,GANyE,CAQrGC,EAA2B,cAE7BR,kHAAM,UAAM,CACRA,GADQ,CAER,uBAFJA,EAF6B,CAR0E,CAkB3G,MAFA,4BAEA,EACH,C,OA7LiC5B,S,IAAjBe,O,u4BCzBrB,M,2DAkBqBsB,G,YAMjB,YAAuC,IAA1BC,GAA0B,yCAA1BA,EAA0B,UAAT,CAAS,mFAEnC,cAFmC,CAGnC,SAHmC,EAItC,C,6CAKaC,WAAsD,YAahE,MAZAA,WAAkB,WAAa,CAC3B,WAAI,UAAJ,CAAgC,CAC5B,GAAIC,GAAJ,MACA,eAF4B,CAG5BC,0BAAoC,CAApCA,OAAoC,CAApCA,CAHJ,KAKK,IAAIC,0BAA0B,QAAOC,GAAP,CAAOA,CAAjCD,EAA0DC,EAA9D,CAA8DA,aAA9D,CAA2F,CAC5F,GAAIC,GAAOD,EAAX,CAAWA,CAAX,CACA,cAAwBA,EAAxB,CAAwBA,CAFoE,CAG5FF,0BAAmC,CAAE3B,MAAO6B,EAA5CF,CAA4CE,CAAT,CAAnCF,CACH,CAVLF,EAYA,KACH,C,6BA0BcM,WAA8D,YACrEC,EAAUD,OAAd,IAAcA,CAD2D,CAiBzE,MAdAJ,4CAAoD,CAApDA,QAAoD,CAApDA,CAcA,CAbAA,iCAA0C,CAAE3B,MAA5C2B,IAA0C,CAA1CA,CAaA,CAZAA,iCAA0C,CAAE3B,MAAO,WAAU,CACzD,MAAOuB,oBAAP,IAAOA,KADXI,CAA0C,CAA1CA,CAYA,CATAA,qCAA8C,CAAE3B,MAAO,WAAU,CAC7D,MAAOuB,wBAAP,IAAOA,KADXI,CAA8C,CAA9CA,CASA,CALAA,YAAa,KAAbA,kBAAsC,WAAiB,CACnDA,0BAA2C,CAAE3B,MAAO,cAApD2B,UAA2C,CAA3CA,CADJA,EAKA,EACH,C,sCAtCyB,CACtB,MAAO,oBAAoB,KAA3B,WAAO,CACV,C,kCAKqB,CAClB,MAAO,oBAAoB,WAAa,KAAb,YAAgC,KAA3D,OAAO,CACV,C,4BAGe,CACZ,MAAO,MAAP,UACH,C,kCA0ByB,CAAE,aAAiB,C,gCACnB,CAAE,QAAc,C,OA5EJzC,S,IAArBqC,O,+/BClBrB,M,2DAaqBU,G,YAUjB,aAAyD,IAAxBT,GAAwB,oDAAP,CAAO,wFAGrD,sBAA0B,GAAID,GAA9B,OAHqD,CAIrD,kBAAuB,GAAIA,GAA3B,OAJqD,CAOrDI,oCAA0C,CAAE3B,MAAO,WAAnD2B,SAA0C,CAA1CA,CAPqD,CAQrDA,iCAAuC,CAAE3B,MAAO,WAAhD2B,MAAuC,CAAvCA,CARqD,CAUrD,UAAI,UAViD,EAWjD,WAXiD,EAaxD,C,8CAOcO,WAAyB,YAC7BA,YAAP,QADoC,EAEpCA,OAAc,uBAAmB,gCAAnB,SAAmB,CAAjCA,SAAgF,uBAAgB,gCAAhB,SAAgB,CAAhGA,EACH,C,wCAK+C,mCAA7BxC,EAA6B,qBAA7BA,KAA6B,YAA7BA,CACf,GAAMwC,GAAU,YAAa,aAAuB,IAC5CC,GAAgB,mBAAuB,WAAY,CACnDA,GADmD,CAEnDC,GAFmD,CAGnDC,IAHJ,CAAoB,CAD4B,CAO5CD,EAAe,gBAAoB,WAAY,CAC/CD,GAD+C,CAE/CC,GAF+C,CAG/CE,IAHJ,CAAmB,CAP6B,CAahD,uBAbJ,CAAgB,CAAhB,CAgBA,QACH,C,kCA/B0D,CACvD,MAAO,oBAAoB,KAA3B,cAAO,CACV,C,OA3B6Ff,S,IAA7EU,O,45CCbrB,M,wDAWqBM,E,YAGjB,YAAc,4EAEb,C,uDAOc,CACX,sFAAe,KAAf,MACH,C,4BAKaC,aAAsE,YAAjCC,EAAiC,yCAAjCA,EAAiC,UAAR,CAAQ,EAChF,WAAa,KAAb,KAAa,IADmE,CAEhF,cAAyBD,EAAzB,KAFgF,CAGhF,gBAAsB,kBAAS,YAAT,SAAS,CAA/B,EACH,C,wBAKSE,aAA0F,CAE5F,UAF4F,CAChG,UAAI,UAD4F,CAE/EA,EAAc,KAA3B,KAAaA,CAF+E,CAK5F,KAAkB,KAAlB,QAL4F,CAQhG,mBARgG,CAShG,UAAI,UAT4F,EAU5FpD,GAEP,C,kCAGyB,CAAE,cAAkB,C,OA3CEW,S,IAA/BsC,O,6hBCXrB,M,wDAIqBI,E,WAInB,YAA6D,YAAhDC,EAAgD,oDAAL,CAAK,eAC3DjB,uBAA+B,kBAAW,MAAX,IAA/BA,EACD,C,iDAEiD,YAChD,MAAO,0BACI,4BAAO,QAAO,MAAP,MADX,OAEC,+BAFD,UAGI,oBAAYA,QAAZ,MAAYA,QAHvB,CAAO,CAIR,C,WAbkBgB,O,gBCLrB,0B,cAAA,+B,+iBCCSE,O,qGACAA,O,kGACAA,O,4FACAA,O,6FACAA,O,yFACAA,O,+FAEAA,O,kGACAA,O,qFACAA,O,+FACAA,O,uCAJGC,K,KAMAC,I,gBCbZ,kC,q4BCCA,M,wDAcqBC,E,YACjB,aAAkC,8EAEjC,C,8CAScd,WAAyB,YAC7BA,YAAP,QADoC,EAEpCA,OAAc,uBAAmB,gCAAnB,SAAmB,CAAjCA,SAAgF,uBAAgB,gCAAhB,SAAgB,CAAhGA,EACH,C,kCAPqB,CAClB,MAAO,oBAAoB,KAA3B,cAAO,CACV,C,OAVyFD,S,IAAzEe,O,maCdjBC,EAAQrB,gBAAZ,K,CAMqBP,E,WASjB,eAAyE,gBAPzE6B,KAOyE,SANzEC,mBAMyE,IACrE,mBADqE,CAErE,gBAFqE,CAGrE,aACH,C,0CAIQ,CACL,yBAA2B,KAA3B,CAAsC,KAAtC,MADK,CAEL,WAAa,KAAb,CAAwB,KAAxB,MACH,C,sBAEO7D,WAAkC,YAChC8D,EAAU,sBAAuB,oBAAqBjD,UAAmB,kBAAxC,IAAwC,GAAnBA,CAA5D,CAAgB,CADsB,CAItC,MAFA,iBAEA,CAAO,iBAAM,WAAiB,sBAAvB,CAAM,CAAb,CACH,C,4BAEaU,WAAuB,CACjC,MAAO,WAAW,CACd,GAAIwC,GAAWJ,OAAf,SAAeA,CAAf,CACA,GAAI,KAAJ,mBAAI,GAAJ,CACI,OAAQ,KAAR,WACI,aAAkB,KAAM,WAAN,sDAAM,CAAN,CAClB,WAAkB,eAAlB,CAA4C,MAC5C,UAAkB,qBAAlB,CAHJ,CADJ,IAOI,+BAPJ,CAQI,cAAkB,uBAAlB,GAAkB,EARtB,CAWA,mCAbJ,CAeH,C,sDAE8B,CAC3B,IAAK,GAAIpC,GAAT,EAAgBA,EAAI,KAApB,UACI,GAAI,CAAC,KAAL,mBAAK,GAAL,CACI,OAIR,0BAA4B,KAA5B,MAP2B,CAQ3B,aACH,C,6BAzCoB,CAAE,MAAO,mBAAP,MAAkC,C,WAfxCQ,O,kjCCNrB,M,CAAYiC,E,2JACZ,M,QACA,M,QAGA,M,QAIA,M,QAaqBC,E,YAKjB,aAAwB,gFAFxBC,SAEwB,CAFF,GAAIvD,GAAJ,OAEE,CAGpB,GAAIwD,GAAa,oBAAjB,aAAiB,EAAjB,CAHoB,MAKpB,EAAI9B,sBALgB,GAMhB,QAAa,mBACH,0BAAwB8B,KAAxB,MADG,UAEA,oBAAY9B,QAAZ,MAAYA,QAFzB,CAAa,CANG,GAUvB,C,0DAE8B,QAC3B+B,YAAa,KAAbA,QAD2B,CAEvB,CAAC,CAAC,KAAF,SAAkB,CAAC,CAAC,aAAxB,OAF2B,EAGhB,qBAAP,WAHuB,CAKhB,WAAN,WALsB,CAMhB,WAAP,WANuB,CAQpB,GAAIf,GAAJ,QAAiB,WAAxB,MAAO,CACV,C,uCAGkD,CAC/C,MAAO,wBAAP,aAAO,EACV,C,2CAEmB,YACdc,EAAa,uBAAjB,aAAiB,EADC,CAElB9B,uBACY,kBAAU,kBAAV,IAAU,GADtBA,EAED,C,8BAQea,aAAsC,YAClD,0BAAgC,kBAAa,YAAb,SAAa,CAA7C,EACH,C,gCAIQ,CACL,MAAO,mBAAmB,KAA1B,KAAO,CACV,C,OArDsCc,EAAMK,S,EAA5BJ,EACVK,YADUL,CACK,CAAEM,QAASC,UAAX,O,GADLP,O,07BCtBrB,M,CAAYD,E,2JACZ,M,QACA,M,QAKqBS,E,0KACU,CACvB,MAAO,CAAEF,QAAS,CAAEG,YAAa,WAAjC,WAAkB,CAAX,CACV,C,gCAGQ,CACL,MAAO,YAAP,QACH,C,OARmCV,EAAMK,S,EAAzBI,EAIVE,iBAJUF,CAIU,CAAEF,QAASC,UAAX,O,GAJVC,O,iCCFrB,aAA+E,QACvEvB,GAAQ,GAAID,GAAhB,OAD2E,oBAA3BpB,EAA2B,6BAA3BA,EAA2B,GAA3BA,EAA2B,YAA3BA,CAKhD,MADAqB,eAAmBA,UAAnBA,IAAmBA,GAAnBA,YACA,EACH,C,mDAEe0B,U,CAAT,UAAsC,CAAE,MAAOC,iEAAP,SAAOA,GAAgD,C,GACtFC,W,CAAT,UAAsC,CAAE,MAAOD,kEAAP,SAAOA,GAAkD,C,GACxFE,G,CAAT,UAAsC,CAAE,MAAOF,mEAAP,SAAOA,GAAmD,C,GACzFG,Y,CAAT,UAAsC,CAAE,MAAOH,mEAAP,SAAOA,GAAmD,C,GACzFI,U,CAAT,UAAsC,CAAE,MAAOJ,iEAAP,SAAOA,GAAiD,C,IAjBvG,O,2DjBDA,C","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"airflux\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"airflux\"] = factory();\n\telse\n\t\troot[\"airflux\"] = factory();\n})(typeof self !== 'undefined' ? self : this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 10);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 7d84883832a67f444bdd","/* @flow */\nimport * as _ from './utils';\nimport invariant from 'invariant';\nimport EventEmitter from 'eventemitter3';\n\nexport type UnsubscribeFunction = () => void;\n\n\n\n/**\n * Base class of everything.\n * - actions are a directly subclass\n * - stores are inheriting from Listener\n */\nexport default class Publisher {\n    _emitter: EventEmitter = new EventEmitter();\n\n    /**\n     * @protected\n     */\n    constructor() {\n    }\n\n    get eventLabel() : string { return 'event'; }\n\n\n    /**\n     * @abstract\n     */\n    processResult( result: ?Promise< * > ) {}\n\n    /**\n     * Subscribes the given callback for action triggered\n     *\n     * @param {( x: any ) => ?any} callback The callback to register as event handler\n     * @returns {UnsubscribeFunction} Callback that unsubscribes the registered event handler\n     */\n    listen( callback: ( x: any ) => ?any ) : UnsubscribeFunction {\n        invariant( typeof callback === 'function', 'listen has to be given a valid callback function' );\n\n        var aborted = false;\n\n        var eventHandler = ( args ) => {\n            if( aborted ) return;\n            this.processResult( callback.apply( this, args ) );\n        };\n\n        this._emitter.addListener( this.eventLabel, eventHandler );\n\n        return () => {\n            aborted = true;\n            this._emitter.removeListener( this.eventLabel, eventHandler );\n        };\n    }\n\n\n    listenOnce( callback: ( x: any ) => ?any ) : UnsubscribeFunction {\n        invariant( typeof callback === 'function', 'listenOnce has to be given a valid callback function' );\n\n        var unsubscribe = this.listen( ( ...args: any[] ) => {\n            unsubscribe();\n            return callback.apply( this, args );\n        });\n        return unsubscribe;\n    }\n\n    /**\n     * Publishes an event using `this._emitter` (if `shouldEmit` agrees)\n     */\n    triggerSync( ...args: any ) {\n        this._emitter.emit( this.eventLabel, args );\n    }\n\n    /**\n     * Tries to publish the event on the next tick\n     */\n    trigger( ...args: any ) {\n        setTimeout( () => this.triggerSync( ...args ), 0 );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Publisher.js","module.exports = require(\"invariant\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"invariant\"\n// module id = 1\n// module chunks = 0","/* @flow */\n\n/*\n * isObject, extend, isFunction, isArguments are taken from undescore/lodash in\n * order to remove the dependency\n */\nexport function isObject( obj: Object | any ): boolean {\n    var type = typeof obj;\n    return type === 'function' || type === 'object' && !!obj;\n};\n\nexport function isFunction( value: Function | any ) {\n    return typeof value === 'function';\n};\n\nexport function isArguments( value: Object | any ): boolean {\n    return typeof value === 'object' && ('callee' in value) && typeof value.length === 'number';\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/utils.js","/* @flow */\nimport * as _                           from './utils';\nimport invariant                        from 'invariant';\n\nimport Publisher                        from './Publisher';\nimport Join                             from './Join';\nimport type { JoinStrategies }          from './Join';\n\nimport type { UnsubscribeFunction }     from './Publisher';\nimport type Action                      from './Action';\nimport type { ActionFunctor }           from './Action';\nimport type Store                       from './Store';\n\nexport type SubscriptionObj = {\n    stop: Function;\n    listenable: ( Publisher | Array< Publisher > | ActionFunctor< any > );\n};\n\n\n\n\n/**\n * A module of methods related to listening.\n * @constructor\n * @extends {Publisher}\n */\nexport default class Listener extends Publisher {\n    _subscriptions: Array< SubscriptionObj > = [];\n\n\n    /**\n     * An internal utility function used by `validateListening`\n     *\n     * @param {Publisher} listenable The listenable we want to search for\n     * @returns {boolean} The result of a recursive search among `this._subscriptions`\n     */\n    hasListener( listenable: Publisher ) : boolean {\n        // flatten the listenables\n        const pubs : Array< Publisher | ActionFunctor< any > > = this._subscriptions\n            .reduce( ( r, sub ) => r.concat( sub.listenable ), [] );\n\n        return pubs.some( pub => ( pub === listenable || ( pub instanceof Listener && pub.hasListener( listenable ) ) ) );\n    }\n\n\n\n    /**\n     * Checks if the current context can listen to the supplied listenable\n     *\n     * @param {Publisher} listenable An Action or Store that should be listened to.\n     */\n    validateListening( listenable: Publisher | ActionFunctor< any > ) {\n        invariant( listenable !== this, 'Listener is not able to listen to itself' );\n        invariant( typeof listenable.listen === 'function', 'listenable should be a Publisher' );\n        invariant( !( listenable instanceof Listener && listenable.hasListener(this)), 'Listener cannot listen to this listenable because of circular loop' );\n    }\n\n    /**\n     * Sets up a subscription to the given listenable for the context object\n     *\n     * @param {Publisher} listenable An Action or Store that should be listened to.\n     * @param {Function} callback The callback to register as event handler\n     * @param {Function} defaultCallback The callback to register as default handler\n     *\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is the object being listened to\n     */\n    listenTo( listenable: Publisher | ActionFunctor< any >, callback: Function/*, defaultCallback: ?Function*/ ) : SubscriptionObj  {\n        this.validateListening( listenable );\n        invariant( callback != null, 'listenTo should be called with a valid callback' );\n/*\n        if( !!defaultCallback )\n            this.fetchInitialState( listenable, defaultCallback );\n*/\n        var desub = listenable.listen( callback.bind( this ) );\n        var unsubscriber = () => {\n            var index = this._subscriptions.indexOf(subscriptionObj);\n            invariant( index >= 0, 'Tried to remove listen already gone from subscriptions list!' );\n            this._subscriptions.splice( index, 1 );\n            desub();\n        };\n\n        const subscriptionObj = this.addSubscription( unsubscriber, listenable );\n        return subscriptionObj;\n    }\n\n    /**\n     * Stops listening to a single listenable\n     *\n     * @param {Publisher} listenable The action or store we no longer want to listen to\n     * @returns {boolean} True if a subscription was found and removed, otherwise false.\n     */\n    stopListeningTo( listenable: Publisher ) : boolean {\n        var subs = this._subscriptions || [];\n\n        for( var i = 0; i < subs.length; ++i ) {\n            var sub = subs[i];\n            if( sub.listenable === listenable ) {\n                sub.stop();\n                invariant( subs.indexOf( sub ) === -1, 'Failed to remove listen from subscriptions list!' );\n                return true;\n            }\n        }\n        return false;\n    }\n\n    /**\n     * Adds a subscription\n     */\n    addSubscription( stop: () => void, listenable: Publisher | ActionFunctor< any >, ) : SubscriptionObj {\n        const subscriptionObj : SubscriptionObj = { stop, listenable };\n        this._subscriptions.push( subscriptionObj );\n        return subscriptionObj;\n    }\n\n    /**\n     * Removes a subscription\n     */\n    removeSubscription( subscription: SubscriptionObj ) {\n        const index = this._subscriptions.indexOf( subscription );\n        if( index < 0 ) return;\n\n        this._subscriptions.splice( index, 1 );\n    }\n\n\n    /**\n     * Stops all subscriptions and empties subscriptions array\n     */\n    stopListeningToAll() {\n        const subs = this._subscriptions || [];\n        var remaining : number = 0;\n\n        while( remaining = subs.length ) {\n            subs[ 0 ].stop();\n            invariant( subs.length === remaining - 1, 'Failed to remove listen from subscriptions list!' );\n        }\n    }\n\n    /**\n     * Used in `listenTo`. Fetches initial data from a publisher if it has a `state` getter.\n     * @param {Action|Store} listenable The publisher we want to get initial state from\n     * @param {Function|String} defaultCallback The method to receive the data\n     */\n    fetchInitialState( listenable: Store< any >, defaultCallback: Function ) {\n        if( _.isFunction( defaultCallback ) && !!listenable.state ) {\n            var defaultState = ( listenable instanceof Publisher ? listenable.state : null );\n            defaultCallback.call( this, defaultState );\n        }\n    }\n\n    /**\n     * The callback will be called once all listenables have triggered at least once.\n     * It will be invoked with the last emission from each listenable.\n     * @param {Function} callback The method to call when all publishers have emitted\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n     */\n    joinTrailing( callback: Function, ...listenables: Array< Publisher > ) : SubscriptionObj {\n        return this._createJoin( 'last', callback, listenables );\n    }\n\n\n    /**\n     * The callback will be called once all listenables have triggered at least once.\n     * It will be invoked with the first emission from each listenable.\n     * @param {...Publishers} publishers Publishers that should be tracked.\n     * @param {Function|String} callback The method to call when all publishers have emitted\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n     */\n    joinLeading( callback: Function, ...listenables: Array< Publisher > ) : SubscriptionObj {\n        return this._createJoin( 'first', callback, listenables );\n    }\n\n    /**\n     * The callback will be called once all listenables have triggered at least once.\n     * It will be invoked with all emission from each listenable.\n     * @param {...Publishers} publishers Publishers that should be tracked.\n     * @param {Function|String} callback The method to call when all publishers have emitted\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n     */\n    joinConcat( callback: Function, ...listenables: Array< Publisher > ) : SubscriptionObj {\n        return this._createJoin( 'all', callback, listenables );\n    }\n\n\n    /**\n     * The callback will be called once all listenables have triggered.\n     * If a callback triggers twice before that happens, an error is thrown.\n     * @param {...Publishers} publishers Publishers that should be tracked.\n     * @param {Function|String} callback The method to call when all publishers have emitted\n     * @returns {Object} A subscription obj where `stop` is an unsub function and `listenable` is an array of listenables\n     */\n    joinStrict( callback: Function, ...listenables: Array< Publisher > ) : SubscriptionObj {\n        return this._createJoin( 'strict', callback, listenables );\n    }\n\n\n    _createJoin( strategy: JoinStrategies, callback: Function, listenables: Array< Publisher > ) : SubscriptionObj {\n        invariant( listenables.length >= 2, 'Cannot create a join with less than 2 listenables!' );\n\n        // validate everything\n        listenables.forEach( listenable => this.validateListening( listenable ) );\n\n        const stop: UnsubscribeFunction = new Join( listenables, strategy ).listen( callback );\n\n        const subobj : SubscriptionObj = {\n            listenable  : listenables,\n            stop: () => {\n                stop();\n                this.removeSubscription( subobj );\n            }\n        };\n\n        this._subscriptions.push( subobj );\n\n        return subobj;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Listener.js","/* @flow */\nimport Publisher                    from './Publisher';\nimport type { UnsubscribeFunction } from './Publisher';\n\n\nexport interface ActionFunctor< Fn > {\n    _isActionFunctor    : boolean;\n    action              : Action< Fn >;\n    listen              : ( callback: ( x: any ) => ?Promise< * > ) => any;\n    listenOnce          : ( callback: ( x: any ) => ?Promise< * > ) => any;\n};\n\ntype Children = { [key: string]: Action< * > };\n\n\n\n/**\n *\n */\nexport default class Action< Fn > extends Publisher {\n    children    : Children;\n\n    /** Whether or not the triggering of the action is synchronous or at the next tick. */\n    _sync       : boolean;\n\n    constructor( sync?: boolean = false  ) {\n        super();\n        this.children = {};\n        this._sync  = sync;\n    }\n\n    /**\n     * Creates children actions\n     */\n    withChildren( children: Array< Children | string > ) : Action< Fn > {\n        children.forEach( ( child ) => {\n            if( typeof child === 'string' ) {\n                let action = new Action();\n                this.children[ child ] = action;\n                Object.defineProperty( this, child, { value: action } );\n            }\n            else if( Array.isArray( child ) && typeof child[0] === 'string' && child[1] instanceof Action ) {\n                let name = child[ 0 ];\n                this.children[ name ] = child[ 1 ];\n                Object.defineProperty( this, name, { value: child[ 1 ] } );\n            }\n        });\n        return this;\n    }\n\n\n    /**\n     * Returns a synchronous function to trigger the action\n     */\n    get asSyncFunction() : Fn {\n        return this.createFunctor( this.triggerSync );\n    }\n\n    /**\n    * Returns a function to trigger the action, async or sync depending on the action definition.\n     */\n    get asFunction() : Fn {\n        return this.createFunctor( this._sync ? this.triggerSync : this.trigger );\n    }\n\n\n    get exec() : Fn {\n        return this.asFunction;\n    }\n\n\n    /**\n     *\n     */\n    createFunctor( triggerFn: Function ) : any /* ( Fn & ActionFunctor< Fn > )*/ {\n        var functor = triggerFn.bind( this );\n\n        Object.defineProperty( functor, '_isActionFunctor', { value: true } );\n        Object.defineProperty( functor, 'action', { value: this } );\n        Object.defineProperty( functor, 'listen', { value: ( fn ) => {\n            return Action.prototype.listen.call( this, fn );\n        } } );\n        Object.defineProperty( functor, 'listenOnce', { value: ( fn ) => {\n            return Action.prototype.listenOnce.call( this, fn );\n        } } );\n\n        Object.keys( this.children ).forEach( ( childName ) => {\n            Object.defineProperty( functor, childName, { value: this.children[ childName ].asFunction } );\n        });\n\n        // $IgnoreFlow\n        return functor;\n    }\n\n    get eventLabel() : string { return 'event'; }\n    get isAction()  : boolean { return true; }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Action.js","/* @flow */\nimport Action from './Action';\nimport type { ActionFunctor } from './Action';\n\n\ninterface AsyncResultActionFunctor< Fn > {\n    _isActionFunctor    : boolean;\n    action              : Action< Fn >;\n    listen              : ( callback: ( x: any ) => ?Promise< * > ) => any;\n    listenOnce          : ( callback: ( x: any ) => ?Promise< * > ) => any;\n};\n\n\n\nexport default class AsyncResultAction< T, Fn: (...args: Array< any > ) => Promise< T > > extends Action< Fn > {\n    completed       : Action< ( x: T ) => any >;\n    failed          : Action< any >;\n    //_listenFunction : Fn;\n\n    /**\n     * By default we create this type of action as synchronous.\n     * If the action is returning a Promise, it's safe to consider that most of the time the action itself is quite simple,\n     * and therefore doesn't necessitate to be async.\n     */\n    constructor( listenFunction: Fn, sync?: boolean = true ) {\n        super( sync );\n\n        this.children.completed = new Action();\n        this.children.failed = new Action();\n        //this._listenFunction = listenFunction;\n\n        Object.defineProperty( this, 'completed', { value: this.children.completed } );\n        Object.defineProperty( this, 'failed', { value: this.children.failed } );\n\n        if( typeof listenFunction === 'function' ) {\n            this.listen( listenFunction );\n        }\n    }\n\n    get asFunction() : ( Fn & AsyncResultActionFunctor< Fn > ) {\n        return this.createFunctor( this.triggerPromise );\n    }\n\n\n    processResult( promise: ?Promise< T > ) {\n        if( !( promise instanceof Promise ) ) return;\n        promise.then( ( ...response ) => this.completed.trigger( ...response ) ).catch( ( ...error ) => this.failed.asFunction( ...error ) );\n    }\n\n    /**\n     * Returns a Promise for the triggered action\n     */\n    triggerPromise( ...args: any[] ) : Promise< T > {\n        const promise = new Promise( ( resolve, reject ) => {\n            var removeSuccess = this.completed.listen( ( args ) => {\n                removeSuccess();\n                removeFailed();\n                resolve( args );\n            });\n\n            var removeFailed = this.failed.listen( ( args ) => {\n                removeSuccess();\n                removeFailed();\n                reject( args );\n            });\n\n            this.trigger( ...args );\n        });\n\n        return promise;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/AsyncResultAction.js","/* @flow */\nimport Listener from './Listener';\n\n\nexport type StateMutation< State > = ( x: State ) => State;\n\n\n\n\n\n/**\n */\nexport default class Store< State: Object > extends Listener {\n    state  : State;\n\n    constructor() {\n        super();\n    }\n\n\n    /**\n     * Publishes the state to all subscribers.\n     * This ensures that the stores always publishes the same data/signature.\n     */\n    publishState() {\n        super.trigger( this.state );\n    }\n\n    /**\n     * Just like FluxComponent, pipe the content of another Store into the state of this one.\n     */\n    connectStore( store: Store< * >, stateKey: string, initialState?: boolean = false ) {\n        this.state = this.state || {};\n        this.state[ stateKey ] = store.state;\n        this.listenTo( store, state => this.setState( { [ stateKey ]: state } ) );\n    }\n\n    /**\n     * Just like React.Component, modifies the state with whatever you passed\n     */\n    setState( partialState: $Shape< State > | ( currentState: State ) => State, callback?: () => void ) {\n        if( typeof partialState === 'function' ) {\n            this.state = partialState( this.state );\n        }\n        else {\n            this.state = { ...this.state, ...partialState };\n        }\n\n        this.publishState();\n        if( typeof callback === 'function' ) {\n            callback();\n        }\n    }\n\n    /** @private */\n    get eventLabel() : string { return 'change'; }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Store.js","/** @flow */\nimport Publisher from './Publisher';\nimport type Store from './Store';\n\n\nexport default class Environment {\n  $key: string;\n  $value: Store< any >;\n\n  constructor( stores: { [key: string ]: Store< any > } = {} ) {\n    Object.keys( stores ).forEach( ( key ) => this[ key ] = stores[ key ] );\n  }\n\n  getPublishers(): { [key: string ]: Store< any > } {\n    return Object.keys( this )\n      .filter( key => typeof this[ key ].listen === 'function' )\n      .map( key => ( { [key]: this[ key ] } ) )\n      .reduce( ( a, b ) => Object.assign( {}, a, b ) );\n  }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Environment.js","module.exports = require(\"react\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"react\"\n// module id = 8\n// module chunks = 0","/* @flow */\nexport { default as Action }                from './Action';\nexport { default as AsyncResultAction }     from './AsyncResultAction';\nexport { default as PromiseAction }         from './PromiseAction';\nexport { default as Listener }              from './Listener';\nexport { default as Publisher }             from './Publisher';\nexport { default as Store }                 from './Store';\nexport * as Joins                           from './JoinStores';\nexport { default as Environment }           from './Environment';\nexport { default as QueryRenderer }         from './QueryRenderer';\nexport { default as ConnectStore }          from './QueryRenderer';\nexport { default as AirfluxApp } from './AirfluxApp';\n\nexport * as Core                            from './utils';\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","module.exports = require(\"eventemitter3\");\n\n\n//////////////////\n// WEBPACK FOOTER\n// external \"eventemitter3\"\n// module id = 12\n// module chunks = 0","/* @flow */\nimport AsyncResultAction                from './AsyncResultAction';\nimport type Action, { ActionFunctor }   from './Action';\n\nexport type PromiseFunctor = any;/*$All< ActionFunctor< * >, {\n    completed   : Action< * >;\n    failed      : Action< * >;\n} >;\n*/\n\n\n/**\n * @example\n *   new PromiseAction( () => fetch( '/url' ) )\n */\nexport default class PromiseAction< T, Fn: (...args: Array< any > ) => Promise< T > > extends AsyncResultAction< T, Fn > {\n    constructor( listenFunction: Fn ) {\n        super( listenFunction );\n    }\n\n    /**\n    * Returns a function to trigger the action, async or sync depending on the action definition.\n     */\n    get asFunction() : Fn {\n        return this.createFunctor( this.triggerPromise );\n    }\n\n    processResult( promise: ?Promise< T > ) {\n        if( !( promise instanceof Promise ) ) return;\n        promise.then( ( ...response ) => this.completed.trigger( ...response ) ).catch( ( ...error ) => this.failed.asFunction( ...error ) );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/PromiseAction.js","/* @flow */\nvar slice = Array.prototype.slice;\nimport type Publisher from './Publisher';\n\nexport type JoinStrategies = 'strict' | 'first' | 'last' | 'all';\n\n\nexport default class Join {\n    _strategy           : string;\n    _args               : Array< any > = [];\n    _listenablesEmitted : Array< boolean > = [];\n    _callback           : Function;\n    _listenables        : Array< Publisher >;\n\n\n\n    constructor( listenables: Array< Publisher >, strategy: JoinStrategies ) {\n        this._listenables = listenables;\n        this._strategy = strategy;\n        this._reset();\n    }\n\n    get count() : number { return this._listenables.length; }\n\n    _reset() {\n        this._listenablesEmitted = new Array( this.count );\n        this._args = new Array( this.count );\n    }\n\n    listen( callback: Function ) : () => void {\n        const cancels = this._listenables.map( ( listenable, i ) => listenable.listen( this._newListener( i ).bind( this ) ) )\n        this._callback = callback;\n\n        return () => cancels.forEach( ( cancel ) => cancel() );\n    }\n\n    _newListener( i: number ) : Function {\n        return function() {\n            var callargs = slice.call( arguments );\n            if( this._listenablesEmitted[ i ] ) {\n                switch( this._strategy ){\n                    case \"strict\"   : throw new Error( \"Strict join failed because listener triggered twice.\" );\n                    case \"last\"     : this._args[i] = callargs; break;\n                    case \"all\"      : this._args[i].push( callargs );\n                }\n            } else {\n                this._listenablesEmitted[ i ] = true;\n                this._args[i] = ( this._strategy === \"all\" ? [ callargs ] : callargs );\n            }\n\n            this._emitIfAllListenablesEmitted();\n        };\n    }\n\n    _emitIfAllListenablesEmitted() {\n        for( var i = 0; i < this.count; ++i ) {\n            if( !this._listenablesEmitted[i] ) {\n                return;\n            }\n        }\n\n        this._callback.apply( null, this._args );\n        this._reset();\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/Join.js","/* @flow */\nimport * as React from 'react';\nimport PropTypes            from 'prop-types';\nimport invariant            from 'invariant';\n\n// airflux\nimport Listener from './Listener';\nimport type Publisher from './Publisher';\nimport type Action from './Action';\nimport type Store from './Store';\nimport Environment from './Environment';\nimport type { AirfluxApi } from './AirfluxApi';\n\ntype QueryRendererProps = {\n  environment?: Environment;\n  render: ( stores: { [ name: string ]: any } ) => any;\n  stores?: { [key: string ]: Store< any > };\n};\n\n\n\n/**\n */\nexport default class QueryRenderer extends React.Component< QueryRendererProps, { [ name: string ]: any }> {\n    static contextTypes = { airflux: PropTypes.object };\n\n    _listener: Listener = new Listener();\n\n    constructor( props: * ) {\n        super( props );\n\n        var publishers = this._getEnvironment().getPublishers();\n\n        if( Object.keys( publishers ).length > 0 ) {\n            this.state = Object.keys( publishers )\n                .map( ( name ) => ( { [name]: publishers[ name ].state } ) )\n                .reduce( ( a, b ) => Object.assign( {}, a, b ) );\n        }\n    }\n\n    _getEnvironment(): Environment {\n        console.log( this.context );\n        if( !!this.context && !!this.context.airflux ) {\n            return this.context.airflux.environment;\n        }\n        else if( !!this.props.environment )\n            return this.props.environment;\n\n        return new Environment( this.props.stores );\n    }\n\n\n    getPublishers() : { [key: string ]: Store< any > } {\n        return this._getEnvironment().getPublishers();\n    }\n\n    componentDidMount() {\n      var publishers = this._getEnvironment().getPublishers();\n      Object.keys( publishers )\n        .forEach( ( st ) => this._listenToStore( publishers[ st ], st ) );\n    };\n\n    /**\n     * Starts listening to a store.\n     * The state of the store will be connected to the state of the componentWillUnmount\n     * @param  {Store} store\n     * @param  {string} stateKey\n     */\n    _listenToStore( store: Store< * >, stateKey: string ) {\n        this._listener.listenTo( store, ( value ) => this.setState( { [stateKey]: value } ) );\n    }\n\n\n\n    render() {\n        return this.props.render( this.state );\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/QueryRenderer.jsx","/* @flow */\nimport * as React from 'react';\nimport PropTypes            from 'prop-types';\nimport invariant            from 'invariant';\nimport type Environment     from './Environment';\nimport type { AirfluxApi }  from './AirfluxApi';\n\n\nexport default class AirfluxApp extends React.Component< { environment: Environment; children: React.Node }, void > {\n    getChildContext() : Object { \n        return { airflux: { environment: this.props.environment } }; \n    }\n    static childContextTypes = { airflux: PropTypes.object };\n\n    render() {\n        return this.props.children;\n    }\n}\n\n\n\n// WEBPACK FOOTER //\n// ./src/AirfluxApp.js","/* @flow */\nimport Store from './Store';\n\nexport type Strategies = 'joinStrict' | 'joinLeading' | 'joinTrailing' | 'joinConcat';\n\n\nfunction joinClassFactory( strategy: Strategies, ...listenables ) : Store< * > {\n    var store = new Store();\n\n    // TODO: when flow supports :: syntax, switch to it\n    store[ strategy ]( store.trigger.bind( store ), ...listenables );\n    return store;\n}\n\nexport function joinStrict() : Store< * >    { return joinClassFactory( 'joinStrict', ...arguments ) };\nexport function joinLeading() : Store< * >   { return joinClassFactory( 'joinLeading', ...arguments ); };\nexport function all() : Store< * >           { return joinClassFactory( 'joinTrailing', ...arguments ); };\nexport function joinTrailing() : Store< * >  { return joinClassFactory( 'joinTrailing', ...arguments ); };\nexport function joinConcat() : Store< * >    { return joinClassFactory( 'joinConcat', ...arguments ); };\n\n\n\n// WEBPACK FOOTER //\n// ./src/JoinStores.js"],"sourceRoot":""}